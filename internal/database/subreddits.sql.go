// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: subreddits.sql

package database

import (
	"context"

	"github.com/adhupraba/breadit-server/internal/db_types"
)

const createSubreddit = `-- name: CreateSubreddit :one
INSERT INTO subreddits (name, creator_id) VALUES ($1, $2) RETURNING id, name, creator_id, created_at, updated_at
`

type CreateSubredditParams struct {
	Name      string             `db:"name" json:"name"`
	CreatorID db_types.NullInt32 `db:"creator_id" json:"creatorId"`
}

func (q *Queries) CreateSubreddit(ctx context.Context, arg CreateSubredditParams) (Subreddit, error) {
	row := q.db.QueryRowContext(ctx, createSubreddit, arg.Name, arg.CreatorID)
	var i Subreddit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSubredditByName = `-- name: FindSubredditByName :one
SELECT id, name, creator_id, created_at, updated_at FROM subreddits WHERE name = $1
`

func (q *Queries) FindSubredditByName(ctx context.Context, name string) (Subreddit, error) {
	row := q.db.QueryRowContext(ctx, findSubredditByName, name)
	var i Subreddit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const findSubredditOfCreator = `-- name: FindSubredditOfCreator :one
SELECT id, name, creator_id, created_at, updated_at FROM subreddits WHERE id = $1 AND creator_id = $2
`

type FindSubredditOfCreatorParams struct {
	ID        int32              `db:"id" json:"id"`
	CreatorID db_types.NullInt32 `db:"creator_id" json:"creatorId"`
}

func (q *Queries) FindSubredditOfCreator(ctx context.Context, arg FindSubredditOfCreatorParams) (Subreddit, error) {
	row := q.db.QueryRowContext(ctx, findSubredditOfCreator, arg.ID, arg.CreatorID)
	var i Subreddit
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatorID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const searchSubreddits = `-- name: SearchSubreddits :many
WITH vars (name, user_id) AS (
	VALUES ($3::TEXT, $4::INT)
)
SELECT
  DISTINCT subre.id, subre.name, subre.creator_id, subre.created_at, subre.updated_at,
  COALESCE(post_agg.post_count, 0) AS post_count,
  COALESCE(sub_agg.sub_count, 0) AS sub_count
FROM subreddits AS subre
  INNER JOIN subscriptions AS sub ON sub.subreddit_id = subre.id
  LEFT JOIN (
    SELECT subreddit_id, COUNT(*) AS post_count
    FROM posts
    GROUP BY subreddit_id
  ) AS post_agg ON post_agg.subreddit_id = subre.id
  LEFT JOIN (
    SELECT subreddit_id, COUNT(*) AS sub_count
    FROM subscriptions
    GROUP BY subreddit_id
  ) AS sub_agg ON sub_agg.subreddit_id = subre.id,
  vars
WHERE
  subre.name LIKE vars.name AND (
    CASE
      WHEN vars.user_id IS NULL THEN TRUE
      ELSE sub.user_id = vars.user_id
    END
  )
ORDER BY subre.name ASC
OFFSET $1 LIMIT $2
`

type SearchSubredditsParams struct {
	Offset int32              `db:"offset" json:"offset"`
	Limit  int32              `db:"limit" json:"limit"`
	Name   string             `db:"name" json:"name"`
	UserID db_types.NullInt32 `db:"user_id" json:"userId"`
}

type SearchSubredditsRow struct {
	Subreddit Subreddit `db:"subreddit" json:"subreddit"`
	PostCount int64     `db:"post_count" json:"postCount"`
	SubCount  int64     `db:"sub_count" json:"subCount"`
}

func (q *Queries) SearchSubreddits(ctx context.Context, arg SearchSubredditsParams) ([]SearchSubredditsRow, error) {
	rows, err := q.db.QueryContext(ctx, searchSubreddits,
		arg.Offset,
		arg.Limit,
		arg.Name,
		arg.UserID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchSubredditsRow
	for rows.Next() {
		var i SearchSubredditsRow
		if err := rows.Scan(
			&i.Subreddit.ID,
			&i.Subreddit.Name,
			&i.Subreddit.CreatorID,
			&i.Subreddit.CreatedAt,
			&i.Subreddit.UpdatedAt,
			&i.PostCount,
			&i.SubCount,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
